# Shell scripts <-> Pash AST (without OCaml)



## Overall status

* Shell script <-> JSON
    * Shell script -> JSON, C implementation: 99.9% complete
    * JSON -> shell script, C implementation: 99.9% complete

N.B. Pash already has functions for JSON <-> Past AST (*).

* Shell script <-> Pash AST, skipping JSON entirely
    * Shell script -> Pash AST, Python implementation: not started
    * Pash AST -> shell script, Python implementation: 99.9% complete

(*) The Pash AST is defined as the data structure obtained
from `parse_json_ast_string (json)`, and which can be used as
input to `serialize_asts_to_json (asts)`.



## Design Notes

The libdash unparser is actually pure OCaml code, without any calls to the C dash library; i.e., the current pipeline from Pash Python AST to shell script is:
1. Pash Python AST -> JSON (json_ast: serialize_asts_to_json)
2. JSON -> libdash OCaml AST (Ast_json.t_of_string, auto-generated by atdgen)
3. libdash OCaml AST -> shell script (the second half of ast.ml)
which does not use the Dash C AST at all.

This is simpler than the parsing direction, which requires the (lib)dash C library i.e.,
1. shell script -> Dash C AST (most of the bindings in dash.ml, calling libdash's underlying C code)
2. Dash C AST -> libdash OCaml AST (the first half of ast.ml)
3. libdash OCaml AST -> JSON (Ast_json.string_of_t, auto-generated by atdgen)
4. JSON -> Pash Python AST (json_ast: parse_json_ast_string)

The upshot of this is that, if we skip the JSON step, the unparsing pipeline can be simplified to:
1. Pash Python AST -> shell script

which can be done in pure Python code. Voila: https://github.com/andromeda/pash/blob/ceda/compiler/parser/ceda/ast2shell.py

Compare to the to_string function of the libdash OCaml unparser: https://github.com/angelhof/libdash/blob/ef6302502b904e33dd4cc686d71142fb1a87bbbd/ocaml/ast.ml)

The parsing pipeline, sans JSON, would still require the C dash library (albeit without OCaml):
1. shell script -> Dash C AST
4. Dash C AST -> Pash Python AST



## Pre-requisites for C implementations

* json-c v0.15:

```
cd /pash
wget https://s3.amazonaws.com/json-c_releases/releases/json-c-0.15.tar.gz
tar zxf json-c-0.15.tar.gz
cd json-c-0.15
mkdir build
cd build/
cmake -DCMAKE_INSTALL_PREFIX=/pash/json-c-0.15/install ../
make install
```



## Usage

### Shell script -> JSON (C implementation)

It has the same usage as `parse_to_json` i.e.,
`./parse_to_json2 SCRIPT_FILE_NAME` or `./parse_to_json2 < SCRIPT_FILE_NAME`

e.g.,
```
$ ./parse_to_json2 /pash/evaluation/hello-world.sh
```

### JSON -> shell script (C implementation)

It has the same usage as `json_to_shell` i.e.,
`./json_to_shell2 JSON_FILE_NAME` or `./json_to_shell2 < JSON_FILE_NAME`

e.g.,

```
$ cat /pash/evaluation/hello-world.sh | ./parse_to_json2 | ./json_to_shell2
if [ $(uname) = "Darwin" ]; then a=/usr/share/dict/web2; else a=/usr/share/dict/words; fi
if [ -f ${a} ]; then cat ${a} ${a} ${a} ${a} ${a} ${a} ${a} ${a} | grep "\\(.\\).*\\1\\(.\\).*\\2\\(.\\).*\\3\\(.\\).*\\4" | wc -l; else echo "Dictionary file ${a} not found.."; fi
```

### Shell script -> Pash AST (TODO)

### Pash AST -> shell script (Python implementation)

ast2shell.py :: string_of

See the misleadingly-named rt.py for example usage

* Secret sauce: `export PYTHONIOENCODING=charmap`

## Testing (with an individual test case)

### Shell script -> JSON (C implementation)

```
sh test_parse_to_JSON2.sh SOME_SCRIPT_FILE
```

This applies the OCaml implementation of `parse_to_json` to the specified script file, and compares the output against this re-implementation.

Output:
* `INVALID_INPUT_1` means the shell script cannot be parsed to JSON by the reference implementation. 
* `ABORT` or `FAIL` means there's a bug in Thurston's code.
* `PASS` is good.

### JSON -> shell script (C implementation)

```
sh test_JSON_to_shell2.sh SOME_SCRIPT_FILE
```

This applies the OCaml implementation of `parse_to_json` to the specified script file, then compares the OCaml `json_to_shell` against this re-implementation.

Output:
* `INVALID_INPUT_1` or `INVALID_INPUT_2` means the shell script cannot be parsed to or from JSON by the reference implementation. 
* `ABORT` or `FAIL` means there's a bug in Thurston's code.
* `PASS` is good.

### Combo: shell script -> JSON -> shell script (C implementation)

```
sh test_rt.sh SOME_SCRIPT_FILE
```

This compares the output of the OCaml pipeline (parse_to_json + json_to_shell) against the C reimplementation (parse_to_json2 + json_to_shell2).



## Testing (with all the scripts in /pash/)

This includes `test_JSON_to_shell2.sh` and any other helper scripts in my local copy of PaSh, hence
the number of scripts may vary on your system.


```
make testsRT # Uses test_rt.sh

make testsA # Uses test_parse_to_json2.sh
make testsB # Uses test_parse_to_json2.sh

make testsB_py # Uses test_ast2shell_py.sh
```

### testsRT: parse_to_json2.c + json_to_shell2.c round-trip results
```
    341 PASS
     33 REF_ABORT_1
```

### testsA: parse_to_json2.c results

Failures are because the Background line number is not initialized by dash for some shell scripts
(the libdash OCaml implementation returns "random" values). As discussed via email, this is not relevant to
PaSh.

```
     11 FAIL
     33 INVALID_INPUT
    330 PASS
```

### testsB: json_to_shell2.c results

All shell scripts that the OCaml implementation works on are regenerated, byte-for-byte identical:
```
     33 INVALID_INPUT_1
    341 PASS
```

### testsB_py: ast2shell.py results

When using ASCII or UTF-8 encoding, there are three failures/aborts, due to weird non-ASCII
characters that don't play nicely with Python:
```
      3 ABORT
    338 PASS
     33 REF_ABORT_1
```

```
ABORT: '/pash/evaluation/poets/pipelines.sh' | /tmp/rt_ocaml.28692 /tmp/rt_py.28692
ABORT: '/pash/compiler/parser/run_parser_on_scripts.sh' | /tmp/rt_ocaml.29910 /tmp/rt_py.29910
ABORT: '/pash/compiler/parser/libdash/ltmain.sh'
```

The two failures/aborts (depending on the settings)
 disappear when we use `export PYTHONIOENCODING=charmap`.
The remaining "ABORT" case (ltmain.sh) actually happens in parse.py::parse_shell even with
the OCaml implementation i.e., not in ast2shell.py.

## Mapping of Files between C and OCaml implementations

* arg_char.c => ast.ml (part 1A: just the arg_char type and associated functions, used for parsing to JSON)
* ast2a.c => ast.ml (part 1B: everything else for parsing to JSON)
* ast2b.c => ast.ml (part 2: everything for serializing JSON to shell)

* dash2.c => dash.ml

* ast2json.c => Ast_json.ml
    * OCaml version was auto-generated by atdgen
    * Notice that we did not implement converting JSON to our AST; json_to_shell2 directly serializes the JSON data structures.

* json_to_shell2.c => json_to_shell.ml
* parse_to_json2.c => parse_to_json.ml 

* CharList.c, Stack.c => basic data structures that OCaml has built-in

For testing only:
* prettyprint_json.c 

## Known Bugs

### parse_to_json2.c
* Memory leaks galore
* To keep the code somewhat resembling OCaml, I've left in recursion instead of eliminating tail calls. I'm hoping the C compiler will optimize them away; if not, the stack may overflow.
* Not Python

### json_to_shell2.c
* `fresh_marker` for heredocs. This is really obscure and a pain to implement in C. For real-world, non-adversarial settings, just change the marker from "EOF" to some random text.
* Same issue with tail calls
* Not Python

### ast2shell.py
* `fresh_marker` for heredocs
* Non-ASCII characters
